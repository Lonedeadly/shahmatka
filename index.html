<html><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1"><title>Шахматка</title>
<!-- Day.js (даты/форматирование) -->
<script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/isSameOrAfter.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/isSameOrBefore.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/isoWeek.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/weekday.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/minMax.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/resize-observer-polyfill@1.5.1"></script>
<style>
    /* ============================================================
       АДАПТИРОВАННЫЕ СТИЛИ ДЛЯ V8WebKit
       - Убраны CSS Custom Properties (var())
       - Все значения инлайнены
       - Упрощены сложные селекторы
       ============================================================ */

    * { 
      box-sizing: border-box; 
      -webkit-box-sizing: border-box;
    }
    
    label {
        padding: 0px 4px;
    }
    
    .padding {
        padding: 0px 4px;
    }
    
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #1d2433;
	  background: #fff;
	  user-select: none; /* Запретить выделение текста на всей странице */
      
    }

    /* ---------- Layout ---------- */
    .board {
      height: calc(100vh - 1px);
      display: -webkit-flex;
      display: flex;
      -webkit-flex-direction: column;
      flex-direction: column;
      min-height: 420px;
    }

    /* Header row (days) */
    .gridHeader {
      display: -webkit-flex;
      display: flex;
      border-bottom: 2px solid #cfd4e2;
      background: #f7f8fb;
      height: 46px;
    }
    .grid-row-background {
    background-image: linear-gradient(to right, #e0e0e0 1px, transparent 1px);
    background-size: 40px 100%; /* 40px - ширина вашей колонки дня */
    position: relative;
    height: 40px; /* высота строки */
}
    .corner {
      width: 240px;
      min-width: 240px;
      border-right: 1px solid #e6e8ee;
      padding: 10px 10px;
      font-weight: 600;
      color: #6b7485;
      display: -webkit-flex;
      display: flex;
      -webkit-align-items: center;
      align-items: center;
      height: 44px;
    }

    .daysViewport {
      overflow-x: auto; /* Для manual */
  		overflow-y: auto;
      -webkit-flex: 1;
      flex: 1;
      height: 44px;
    }
    
    

    .daysRow {
      display: -webkit-flex;
      display: flex;
      width: -webkit-max-content;
      width: max-content;
      height: 44px;
    }
    
    .dayCell {
      width: 72px;
      min-width: 72px;
      border-right: 1px solid #e6e8ee;
      padding: 6px 6px;
      text-align: center;
      line-height: 1.15;
      -webkit-user-select: none;
      user-select: none;
      font-size: 12px;
      color: #6b7485;
      white-space: nowrap;
      height: 44px;
      display: -webkit-flex;
      display: flex;
      -webkit-align-items: center;
      align-items: center;
      -webkit-justify-content: center;
      justify-content: center;
    }
    
    .dayCell .d {
      font-weight: 650;
      color: #1d2433;
      font-size: 12px;
    }
    
    .dayCell.today { 
      background: #fff2f2; 
    }

    /* Body */
    .gridBody {
      position: relative;
      display: -webkit-flex;
      display: flex;
      -webkit-flex: 1;
      flex: 1;
      min-height: 0;
      background: #fff;
    }
    
    .leftCol {
      width: 240px;
      min-width: 240px;
      border-right: 1px solid #e6e8ee;
      overflow: hidden;
      background: #fff;
    }
    
    .rowsViewport {
      -webkit-flex: 1;
      flex: 1;
      overflow: auto;
      position: relative;
      background: #fff;
    }
    
    /* auto */
	.rowsViewport.auto {
	  overflow-x: hidden;
	}

	/* manual */
	.rowsViewport.manual {
	  overflow-x: auto;
	}
	#daysViewport {
  overflow: hidden;
}
    .rowsContent {
      width: -webkit-max-content;
      width: max-content;
      position: relative;
    }

    .rowLabel {
      height: 40px;
      display: -webkit-flex;
      display: flex;
      -webkit-align-items: center;
      align-items: center;
      padding: 0 10px;
      border-bottom: 1px solid #e6e8ee;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      font-size: 13px;
    }
    
    .rowLabel .meta {
      margin-left: auto;
      font-size: 12px;
      color: #6b7485;
    }
    
    .row {
      position: relative;
      height: 40px;
      border-bottom: 1px solid #e6e8ee;
    }

    .rowInner {
      position: relative;
      height: 100%;
      display: -webkit-flex;
      display: flex;
      width: -webkit-max-content;
      width: max-content;
    }
    
    .gridRow {
	    position: relative; /* Контейнер для абсолютных ячеек */
	    display: block;    /* Убедись, что это не flex, иначе absolute собьется */
	    overflow: hidden;  /* Чтобы ячейки не вылезали за границы */
	}
    .cell {
      width: 72px;
      min-width: 72px;
      border-right: 1px solid #e6e8ee;
      position: relative;
      height: 100%;
    }
    
    .cell:hover { 
      background: #fafbff; 
    }

    /* Selection overlay */
    .selection {
      position: absolute;
      top: 6px;
      height: 30px;
      background: rgba(66, 133, 244, 0.25);
      border: 1px dashed rgba(66, 133, 244, 0.6);
      border-radius: 8px;
      pointer-events: none;
      display: none;
    }

    .bookingsLayer {
      position: relative;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }
    
    .booking-wrap {
	  position: absolute;
	  top: 6px;
	  pointer-events: auto;
	  overflow: visible; 
	  cursor: grab;
  		cursor: -webkit-grab; 
	}
	.booking-wrap:active .booking {
	  cursor: grabbing;
	  cursor: -webkit-grabbing;
	}
	.booking {
	  height: 30px;
	  border-radius: 10px;
	  padding: 6px 8px;
	  font-size: 12px;
	  overflow: hidden; /* ← режем ТОЛЬКО текст */
	  white-space: nowrap;
	  box-shadow: 0 1px 0 rgba(0,0,0,.05),
	              0 6px 18px rgba(0,0,0,.08);
		cursor: grab; 
  cursor: -webkit-grab; 
	}
	.booking:active { 
  cursor: grabbing;
  cursor: -webkit-grabbing;
}
	.booking-label {
	  display: block;
	  overflow: hidden;
	  text-overflow: ellipsis;
	}
	
	.booking[data-locked="true"] {
	  cursor: not-allowed !important;
	  opacity: 0.75;
	}
	.api-badge {
	  position: absolute;
	  top: -6px;
	  right: -6px;
	  font-size: 9px;
	  background: #ff4444;
	  color: #fff;
	  padding: 2px 5px;
	  border-radius: 10px;
	  border: 1px solid #fff;
	  font-weight: bold;
	  line-height: 1;
	  pointer-events: none;
	  z-index: 10;
	}

    
    
    .booking.dragging { 
      opacity: .85; 
      box-shadow: 0 4px 20px rgba(0,0,0,.2);
      z-index: 100;
    }
    
    .booking.drag-invalid {
      opacity: .5;
      border: 2px dashed #e31b23 !important;
    }
	
	.booking-wrap.selected .booking,
	.booking.selected {
	  box-shadow: 0 0 0 2px #2196F3, 0 0 10px rgba(33, 150, 243, 0.5);
	  z-index: 10 !important;
	  transform: scale(1.01);
	}
	
	.apartment-status {
	  position: absolute;
	  top: 6px;
	  height: 30px;
	  border-radius: 8px;  /* Меньше скругление, чем у бронирований */
	  padding: 6px 8px;
	  font-size: 12px;
	  overflow: hidden;
	  white-space: nowrap;
	  text-overflow: ellipsis;
	  pointer-events: auto;
	  cursor: grab; 
	  cursor: -webkit-grab; 
	  -webkit-user-select: none;
	  user-select: none;
	  border: 1px dashed rgba(0,0,0,.15);  /* Пунктирная граница */
	  color: #1d2433;
	  opacity: 0.7;
	}
	
	.apartment-status:active { 
      cursor: grabbing;
      cursor: -webkit-grabbing;
    }
    
    .apartment-status.dragging { 
      opacity: .85; 
      box-shadow: 0 4px 20px rgba(0,0,0,.2);
      z-index: 100;
    }
    
    .apartment-status.drag-invalid {
      opacity: .5;
      border: 2px dashed #e31b23 !important;
    }
    
    .apartment-status.selected {
	  box-shadow: 0 0 0 2px #4CAF50, 0 0 10px rgba(76, 175, 80, 0.5);
	  z-index: 10 !important;
	  transform: scale(1.01);
	  opacity: 0.8 !important;
	}

	.info-popover {
	  z-index: 1000 !important;
	  user-select: text;
	  cursor: auto;
	}
	
	.popover-buttons {
	display: flex;
	justify-content: flex-start;
	gap: 8px;
	margin-top: 12px;
	padding: 8px 0;
	border-top: 1px solid #e0e0e0;
	}
	.btn-open, .btn-copy {
	padding: 6px 12px;
	font-size: 14px;
	font-weight: 500;
	border: none;
	border-radius: 4px;
	cursor: pointer;
	transition: background-color 0.2s ease, transform 0.1s ease;
	}
	.btn-open {
	background: #007bff;
	color: white;
	}
	.btn-open:hover {
	background: #0056b3;
	transform: translateY(-1px);
	}
	.btn-copy {
	background: #6c757d;
	color: white;
	}
	.btn-copy:hover {
	background: #5a6268;
	transform: translateY(-1px);
	}
	.btn-open:active, .btn-copy:active {
	transform: translateY(0);
	}
    /* Now line */
    .nowLine {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #e31b23;
      z-index: 30;
      pointer-events: none;
    }
    
    .nowLine:before {
      content: "";
      position: absolute;
      top: 0;
      left: -4px;
      width: 10px;
      height: 10px;
      background: #e31b23;
      border-radius: 999px;
      box-shadow: 0 2px 10px rgba(227,27,35,.35);
    }

    /* Popovers / menu */
    .popover {
      position: fixed;
      z-index: 100;
      min-width: 260px;
      max-width: 360px;
      background: #fff;
      border: 1px solid #e6e8ee;
      border-radius: 12px;
      box-shadow: 0 14px 40px rgba(0,0,0,.15);
      padding: 10px 12px;
      display: none;
    }
    
    .popover .title { 
      font-weight: 700; 
      margin-bottom: 6px; 
    }
    
    .popover .kv {
      display: -webkit-flex;
      display: flex;
      -webkit-flex-wrap: wrap;
      flex-wrap: wrap;
      gap: 4px 10px;
      font-size: 12px;
      color: #6b7485;
    }
    
    .popover .kv-row {
      display: -webkit-flex;
      display: flex;
      width: 100%;
      margin-bottom: 4px;
    }
    
    .popover .kv-label {
      width: 110px;
      min-width: 110px;
      color: #6b7485;
    }
    
    .popover .kv-value {
      -webkit-flex: 1;
      flex: 1;
      color: #1d2433;
      font-weight: 600;
    }

    .ctx {
      position: fixed;
      z-index: 120;
      background: #fff;
      border: 1px solid #e6e8ee;
      border-radius: 12px;
      box-shadow: 0 14px 40px rgba(0,0,0,.18);
      padding: 6px;
      display: none;
      min-width: 180px;
    }
    
    .ctx button {
      width: 100%;
      text-align: left;
      border: 0;
      background: transparent;
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
    }
    
    .ctx button:hover { 
      background: #d6ddff; 
    }

    @media (max-width: 840px) {
      .corner,
      .leftCol {
        width: 180px;
        min-width: 180px;
      }
    }
    
    .ui-blocked #app {
	  filter: blur(3px) grayscale(30%);
	  pointer-events: none;
	  transition: filter 0.15s ease;
	}

	.ui-blocked::after {
	  content: "";
	  position: fixed;
	  inset: 0;
	  background: rgba(255,255,255,0.25);
	  z-index: 999;
	}
	.events-container {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-left: 8px;
}

.events-container {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-left: 8px;
}

.event-icon {
    width:  22px;
    height: 22px;
    background: #e8f0fe;           /* светло-голубой, хорошо виден */
    border: 1px solid #c3d7ff;     /* лёгкая обводка для чёткости */
    padding: 3px;
    border-radius: 50%;
    box-shadow: 0 1px 2px rgba(0,0,0,0.08);  /* лёгкая тень — помогает на белом фоне */
}

.event-icon svg {
    width: 100%; /* ← иконка растягивается на весь круг */
    height: 100%;
    fill: currentColor;
}
  </style>
	<body>
		<button id="actionButton" style="display: none;">Скрытая</button>
<div class="board" id="app">
    <div class="gridHeader">
        <div class="corner">Квартиры</div>
        <div class="daysViewport" id="daysViewport">
            <div class="daysRow" id="daysRow"></div>
        </div>
    </div>
    
    <div class="gridBody">
        <div class="leftCol" id="leftCol"></div>
        <div class="rowsViewport" id="rowsViewport">
            <div class="rowsContent" id="rowsContent"></div>
            <div class="nowLine" id="nowLine" style="display:none"></div>
        </div>
    </div>
</div>

<!-- Всплывающая информация о бронировании при наведении -->
<div class="popover" id="infoPopover" aria-hidden="true"></div>

<!-- Контекстное меню по правой кнопке -->
<div class="ctx" id="ctxMenu" aria-hidden="true">
    <button id="ctxOpen">Открыть</button>
    <button id="ctxCopy">Скопировать</button>
</div>
		<script>
			// polyfills.js
if (typeof structuredClone === 'undefined') {
	window.structuredClone = function(obj) {
		return JSON.parse(JSON.stringify(obj));
	};
}

// dayjs-extensions.js
dayjs.extend(dayjs_plugin_isoWeek);
dayjs.extend(dayjs_plugin_weekday);
dayjs.extend(dayjs_plugin_isSameOrAfter);
dayjs.extend(dayjs_plugin_isSameOrBefore);
// utils.js

var dateFormatCache = {};

function getFormattedDate(date, format) {
	var key = date.valueOf() + '|' + format;
	if (!dateFormatCache[key]) {
		dateFormatCache[key] = date.format(format);
	}
	return dateFormatCache[key];
}

function clearFormatCache() {
	dateFormatCache = {};
}

function clamp(n, a, b) {
	return Math.max(a, Math.min(b, n));
}

function dayId(d) {
	return "day-" + d.format("YYYY-MM-DD");
}

function cellId(apartmentId, d) {
	return "cell-" + apartmentId + "-" + d.format("YYYY-MM-DD");
}

function bookingIdStr(b) {
	// Используем комбинацию id и dateCreate для уникальности
	return "booking-" + b.id + "-" + (b.dateCreate || "0");
}

function apartmentStatusIdStr(s) {
	// Используем комбинацию id и dateCreate для уникальности
	return "status-" + s.id + "-" + (s.dateCreate || "0");
}

function isSameStatusPeriod(s1, s2) {
	return s1.apartmentId === s2.apartmentId &&
		s1.start === s2.start &&
		s1.end === s2.end;
}

function apartmentRowId(apartmentId) {
	return "apartment-" + apartmentId;
}

function dispatch(name, detail) {
	var btn = document.getElementById('actionButton');
	btn.setAttribute('data-action', name);
	btn.setAttribute('data-details', JSON.stringify(detail));
	btn.click();
}

function findBookingByIdAndDateCreate(id, dateCreate) {
	return bookings.find(x => String(x.id) === String(id) && String(x.dateCreate) === String(dateCreate));
}

function findStatusByIdAndDateCreate(id, dateCreate) {
	return apartmentStatuses.find(x => String(x.id) === String(id) && String(x.dateCreate) === String(dateCreate));
}

function applyPendingAction(pa) {
	if (pa.type === "booking") {
		var b = findBookingByIdAndDateCreate(pa.id, pa.dateCreate);
		if (b) Object.assign(b, pa.newState);
	}
	if (pa.type === "status") {
		var s = findStatusByIdAndDateCreate(pa.id, pa.dateCreate);
		if (s) Object.assign(s, pa.newState);
	}
}

function rollbackPendingAction(pa) {
	if (pa.type === "booking") {
		var b = findBookingByIdAndDateCreate(pa.id, pa.dateCreate);
		if (b) Object.assign(b, pa.oldState);
	}
	if (pa.type === "status") {
		var s = findStatusByIdAndDateCreate(pa.id, pa.dateCreate);
		if (s) Object.assign(s, pa.oldState);
	}
}

function blockUI() {
	uiBlocked = true;
	document.body.classList.add("ui-blocked");
}

function unblockUI() {
	uiBlocked = false;
	document.body.classList.remove("ui-blocked");
}

function fixPopover(type, id, clientX, clientY) {
	fixedPopover.isFixed = true;
	fixedPopover.type = type;
	fixedPopover.id = id;
	fixedPopover.position = {
		x: clamp(clientX + 16, 8, window.innerWidth - 380),
		y: clamp(clientY + 16, 8, window.innerHeight - 220)
	};

	// Применяем фиксированную позицию
	el.infoPopover.style.left = fixedPopover.position.x + "px";
	el.infoPopover.style.top = fixedPopover.position.y + "px";
	// Устанавливаем класс для видимости подсказки
	el.infoPopover.classList.add("info-popover");
	// Показываем подсказку
	el.infoPopover.style.display = "block";
}

function safe(val) {
	return val || '-';
}

function isInsideApp(el) {
	return el && (el.id === 'app' || findParentWithClass(el, 'board'));
}

function findParentWithClass(element, className) {
	var current = element;
	while (current && current !== document) {
		if (current.classList && current.classList.contains(className)) {
			return current;
		}
		current = current.parentNode;
	}
	return null;
}

function applyScrollMode() {
	el.rowsViewport.classList.toggle("auto", state.periodAuto);
	el.rowsViewport.classList.toggle("manual", !state.periodAuto);
}

function perf(label) {
	const t = performance.now();
	return () => {
		const dt = performance.now() - t;
		console.log(`⏱ ${label}: ${dt.toFixed(1)} ms`);
  };
}

// state.js
var apartmentCache = {}; // Кэш для быстрого поиска квартир
var cachedDates = []; // Кэш для дат

function getApartmentById(id) {
	if (!apartmentCache[id]) {
		apartmentCache[id] = apartments.find(a => a.id === id);
	}
	return apartmentCache[id];
}

function getCachedDate(anchorDate, dayOffset) {
	if (!cachedDates[dayOffset]) {
		cachedDates[dayOffset] = anchorDate.add(dayOffset, "day");
	}
	return cachedDates[dayOffset];
}

function invalidateDateCache() {
	cachedDates = [];
}

var selectedItem = {
	type: null,
	id: null,
	element: null
};
var fixedPopover = {
	isFixed: false,
	type: null,
	id: null,
	position: {
		x: 0,
		y: 0
	}
};
var uiBlocked = false;
var pendingAction = null;
var apartments = [];
var bookings = [];
var apartmentStatuses = []; // Статусы квартир (ремонт, уборка и т.д.)
var statusColors = {};

var state = {
	anchorDate: dayjs().startOf("day"),
	visibleDays: 0,
	columnWidth: 72,
	tariffMode: false,
	selecting: null,
	periodAuto: true,
	periodFrom: null,
	periodTo: null
};

var dragState = null;

var el = {
	daysViewport: document.getElementById("daysViewport"),
	daysRow: document.getElementById("daysRow"),
	leftCol: document.getElementById("leftCol"),
	rowsViewport: document.getElementById("rowsViewport"),
	rowsContent: document.getElementById("rowsContent"),
	nowLine: document.getElementById("nowLine"),
	infoPopover: document.getElementById("infoPopover")
};

var allDaysArray = [];
var totalDaysCount = 0;

var bookingsByApartment = {};
var statusesByApartment = {};

var visibilityState = {
	currentVisibleRange: null,
	lastRequestedRange: null
};

// Функция для определения расширенного диапазона загрузки
function getExtendedLoadRange() {
    if (!state.periodAuto) {
        // РУЧНОЙ ПЕРИОД: загружаем ВЕСЬ период сразу
        return {
            start: state.periodFrom,
            end: state.periodTo
        };
    } else {
        // АВТО ПЕРИОД: используем буфер
        const bufferDays = 14;
        const MAX_LOAD_DAYS = 180;
        
        // Получаем видимый диапазон в виде дат
        const visibleStart = state.anchorDate;
        const visibleEnd = state.anchorDate.add(state.visibleDays, 'day');
        
        let start = visibleStart.subtract(bufferDays, 'day');
        let end = visibleEnd.add(bufferDays, 'day');

        if (end.diff(start, 'day') > MAX_LOAD_DAYS) {
            const halfBuffer = Math.floor(MAX_LOAD_DAYS / 2);
            const visibleCenter = visibleStart.add(state.visibleDays / 2, 'day');
            start = visibleCenter.subtract(halfBuffer, 'day');
            end = visibleCenter.add(halfBuffer, 'day');
        }

        return { start, end };
    }
}

function isEndOfDay(date) {
    // Проверяем, заканчивается ли дата в конце дня (23:59:59)
    return date.hour() === 23 && date.minute() === 59 && date.second() === 59;
}

function isStartOfDay(date) {
    // Проверяем, начинается ли дата в начале дня (00:00:00)
    return date.hour() === 0 && date.minute() === 0 && date.second() === 0;
}
//selection_functions.js
function selectItem(type, id, element, ev) {
	// Снимаем предыдущее выделение
	if (selectedItem.element) {
		selectedItem.element.classList.remove("selected");
	}

	// Устанавливаем новое выделение
	selectedItem.type = type;
	selectedItem.id = id;
	selectedItem.element = element;

	// Добавляем класс выделения
	element.classList.add("selected");

	// Фиксируем подсказку в позиции клика
	if (ev) {
		// Показываем соответствующую подсказку в позиции клика
		if (type === "booking") {
			var booking = findBookingByIdAndDateCreate(id, element.getAttribute("data-date-create"));
			if (booking) {
				fixPopover(type, id, ev.clientX, ev.clientY);
				showBookingPopover(ev, booking, true); // true - для фиксированной позиции
			}
		} else if (type === "status") {
			var status = findStatusByIdAndDateCreate(id, element.getAttribute("data-date-create"));
			if (status) {
				fixPopover(type, id, ev.clientX, ev.clientY);
				showStatusPopover(ev, status, true); // true - для фиксированной позиции
			}
		}
	}

	// Очищаем выделение ячеек если было
	if (state.selecting) {
		clearSelectionOverlay();
		state.selecting = null;
	}
}

function deselectItem() {
	if (selectedItem.element) {
		selectedItem.element.classList.remove("selected");
	}
	selectedItem.type = null;
	selectedItem.id = null;
	selectedItem.element = null;

	// Снимаем фиксацию подсказки
	fixedPopover.isFixed = false;
	el.infoPopover.style.display = "none";
}

function isItemSelected() {
	return selectedItem.element !== null;
}
// period-logic.js

function updateAllDaysArray() {
    if (state.periodAuto) {
        allDaysArray = [];
        totalDaysCount = state.visibleDays;
        for (var i = 0; i < state.visibleDays; i++) {
            allDaysArray.push(state.anchorDate.add(i, 'day'));
        }
    } else {
        // В ручном режиме заполняем массив ВСЕМИ днями периода
        allDaysArray = [];
        totalDaysCount = 0;
        if (state.periodFrom && state.periodTo) {
            var current = state.periodFrom.clone();
            while (current.isSameOrBefore(state.periodTo)) {
                allDaysArray.push(current.clone());
                current = current.add(1, 'day');
            }
            totalDaysCount = allDaysArray.length;
        }
    }
}

function onPeriodChanged() {
    visibilityState.lastRequestedRange = null;
    clearAllCaches(); 
    
    // Всегда обновляем массив дней
    updateAllDaysArray();
    
    const p = getVisibleDaysAndAnchor();
    state.visibleDays = p.days;
    
    checkAndRequestData();
    renderAll();
}

function calcAutoVisibleDays() {
	return Math.floor(el.rowsViewport.clientWidth / state.columnWidth);
}

function getVisibleDaysAndAnchor() {
	if (state.periodAuto) {
		return {
			anchor: state.anchorDate.startOf("day"),
			days: calcAutoVisibleDays()
		};
	}
	
	// Ручной режим
	var from = state.periodFrom;
	var to = state.periodTo;
	if (from && to && (to.isSame(from) || to.isAfter(from))) {
		var totalDays = to.diff(from, "day") + 1;
		var scrollLeft = el.rowsViewport.scrollLeft;
		var scrollDays = Math.floor(scrollLeft / state.columnWidth);
		
		// Количество дней, которые можно показать на экране
		var visibleDays = calcAutoVisibleDays();
		
		// Начало видимой области
		var visibleStart = from.add(scrollDays, 'day');
		
		// Сколько дней осталось от начала видимой области до конца периода
		var daysRemaining = totalDays - scrollDays;
		
		// Видимых дней не может быть больше, чем осталось в периоде
		visibleDays = Math.min(visibleDays, daysRemaining);
		
		return {
			anchor: visibleStart.startOf("day"),
			days: visibleDays
		};
	}
	
	// Fallback на auto, если период неверный
	console.warn('Неверный manual период — fallback на auto');
	return {
		anchor: state.anchorDate.startOf("day"),
		days: calcAutoVisibleDays()
	};
}

const container = document.getElementById('rowsViewport'); // Твой скролл-контейнер

function getVisibleRange() {
    if (state.periodAuto) {
        const p = getVisibleDaysAndAnchor();
        let start = p.anchor.startOf("day");
        let end = start.add(p.days, "day");
        return {
            start,
            end,
            days: p.days
        };
    } else {
        // Ручной режим: видимый диапазон - это весь период
        // (рендерим все дни, но позиционируем со смещением скролла)
        return {
            start: state.periodFrom,
            end: state.periodTo,
            days: allDaysArray.length
        };
    }
}
// render.js
function updateSelectedItemPopover() {
	if (!selectedItem.element) return;

	var rect = selectedItem.element.getBoundingClientRect();
	var ev = {
		clientX: rect.left + rect.width / 2,
		clientY: rect.top + rect.height / 2
	};

	if (selectedItem.type === "booking") {
		var dateCreate = selectedItem.element.getAttribute("data-date-create");
		var booking = findBookingByIdAndDateCreate(selectedItem.id, dateCreate);
		if (booking) showBookingPopover(ev, booking);
	} else if (selectedItem.type === "status") {
		var dateCreate = selectedItem.element.getAttribute("data-date-create");
		var status = findStatusByIdAndDateCreate(selectedItem.id, dateCreate);
		if (status) showStatusPopover(ev, status);
	}
}

function checkAndRequestData(force = false) {
	// Проверяем только если квартиры уже загружены
	if (apartments.length === 0) {
		return;
	}

	const currentRange = getExtendedLoadRange();
	const lastRange = visibilityState.lastRequestedRange;

	// Проверяем, нужно ли загружать новые данные
	if (force ||
		!lastRange ||
		currentRange.start.isBefore(lastRange.start) ||
		currentRange.end.isAfter(lastRange.end)) {

		// Определяем видимые квартиры (все загружены, берем по индексам)
		const visibleRows = getVisibleRowRange();
		const visibleApartmentIds = [];

		for (let i = visibleRows.first; i <= visibleRows.last; i++) {
			if (apartments[i]) {
				visibleApartmentIds.push(apartments[i].id);
			}
		}

		if (visibleApartmentIds.length > 0) {
			requestDocumentsForRange(currentRange.start, currentRange.end, visibleApartmentIds);
		}

		visibilityState.lastRequestedRange = currentRange;
	}
}

function renderAll() {

	const end = perf("renderAll TOTAL");
	
	invalidateDateCache();
	
	let t = perf("renderHeaderDays");
	renderHeaderDays();
	t();
	
	t = perf("renderVisibleRows");
	renderVisibleRows();
	t();
	
	t = perf("renderVisibleItems");
	renderVisibleItems();
	t();
	
	t = perf("updateSelectedItemPopover");
	updateSelectedItemPopover();
	t();
	
	t = perf("renderNowLine");
	renderNowLine();
	t();
	
	t = perf("syncHeaderScroll");
	syncHeaderScroll();
	t();
	
	end();
	
	console.log(
		"DOM stats:",
		"cells =", document.querySelectorAll('.cell').length,
		"rows =", document.querySelectorAll('.row').length,
		"bookings =", document.querySelectorAll('.booking-wrap').length
	);
}


function renderHeaderDays() {
    el.daysRow.innerHTML = "";
    invalidateDateCache();

    let days;

    if (state.periodAuto) {
        days = [];
        for (let i = 0; i < state.visibleDays; i++) {
            days.push(state.anchorDate.add(i, "day"));
        }
    } else {
        // ✅ В РУЧНОМ РЕЖИМЕ — ВСЕ ДНИ ПЕРИОДА
        days = allDaysArray;
    }

    for (let i = 0; i < days.length; i++) {
        const d = days[i];

        const cell = document.createElement("div");
        cell.className = "dayCell" + (d.isSame(dayjs(), "day") ? " today" : "");
        cell.id = dayId(d);
        cell.style.width = state.columnWidth + "px";
        cell.style.minWidth = state.columnWidth + "px";
        cell.innerHTML =
            '<div class="d">' +
            d.format("DD.MM") +
            " (" +
            ["Вс","Пн","Вт","Ср","Чт","Пт","Сб"][d.day()] +
            ")</div>";

        el.daysRow.appendChild(cell);
    }

    el.daysRow.style.width =
        (days.length * state.columnWidth) + "px";
}


function getVisibleRowRange() {
	var rowHeight = 40; // Изменено с 42 на 40 (как в CSS)
	var buffer = 3;

	var scrollTop = el.rowsViewport.scrollTop;
	var viewportHeight = el.rowsViewport.clientHeight;

	var first = Math.max(
		0,
		Math.floor(scrollTop / rowHeight) - buffer
	);

	var last = Math.min(
		apartments.length - 1,
		Math.ceil((scrollTop + viewportHeight) / rowHeight) + buffer
	);

	return {
		first: first,
		last: last,
		rowHeight: rowHeight
	};
}

function getVisibleColumnRange() {
    const scrollLeft = el.rowsViewport.scrollLeft;
    const viewportWidth = el.rowsViewport.clientWidth;
    const cellWidth = state.columnWidth;
    const buffer = 5;

    // Общее количество дней для расчета
    const totalDays = state.periodAuto ? state.visibleDays : allDaysArray.length;
    
    const first = Math.floor(scrollLeft / cellWidth);
    const last = Math.ceil((scrollLeft + viewportWidth) / cellWidth);

    return {
        first: Math.max(0, first - buffer),
        last: Math.min(totalDays - 1, last + buffer),
        cellWidth: cellWidth
    };
}

function renderVisibleRows() {
    var rowRange = getVisibleRowRange();
    var colRange = getVisibleColumnRange(); // Новое: получаем диапазон колонок

    el.leftCol.innerHTML = "";
    el.rowsContent.innerHTML = "";

    el.leftCol.style.paddingTop = (rowRange.first * rowRange.rowHeight) + "px";
    el.rowsContent.style.paddingTop = (rowRange.first * rowRange.rowHeight) + "px";

    var fragL = document.createDocumentFragment();
    var fragR = document.createDocumentFragment();

    for (var i = rowRange.first; i <= rowRange.last; i++) {
        var ap = apartments[i];

        // Левая колонка (названия номеров) - остается без изменений
        var lbl = document.createElement("div");
        lbl.className = "rowLabel";
        lbl.id = apartmentRowId(ap.id);
        lbl.textContent = ap.name;
        fragL.appendChild(lbl);

        // Правая колонка - передаем colRange для виртуализации ячеек внутри строки
        var row = buildGridRow(ap.id, apartmentRowId(ap.id), colRange);
        fragR.appendChild(row);
    }

    el.leftCol.appendChild(fragL);
    el.rowsContent.appendChild(fragR);
}

function buildGridRow(apartmentId, rowKey, colRange) {
    var row = document.createElement("div");
    row.className = "row";
    row.setAttribute("data-apartment-id", String(apartmentId));
    row.setAttribute("data-row-key", rowKey);
    
    // ВАЖНО: Используем правильное количество дней
    const totalDays = state.periodAuto ? state.visibleDays : allDaysArray.length;
    row.style.width = (totalDays * colRange.cellWidth) + "px";
    
    row.style.position = "relative";
    row.style.height = "40px";

    // Создаем контейнер для ячеек
    var cellsContainer = document.createElement("div");
    cellsContainer.style.position = "absolute";
    cellsContainer.style.width = "100%";
    cellsContainer.style.height = "100%";
    
    // Создаем ячейки только для видимого диапазона
    for (var j = colRange.first; j <= colRange.last; j++) {
        var day = allDaysArray[j];
        var cell = document.createElement("div");
        cell.className = "cell";
        cell.setAttribute("data-apartment-id", String(apartmentId));
        cell.setAttribute("data-date", day.format ? day.format("YYYY-MM-DD") : dayjs(day).format("YYYY-MM-DD"));
        cell.setAttribute("data-index", String(j));
        cell.setAttribute("data-row-key", rowKey);
        cell.style.position = "absolute";
        cell.style.left = (j * colRange.cellWidth) + "px";
        cell.style.width = colRange.cellWidth + "px";
        cell.style.height = "100%";
        cellsContainer.appendChild(cell);
    }
    
    // СОЗДАЕМ СЛОЙ ДЛЯ ВЫДЕЛЕНИЯ
    var sel = document.createElement("div");
    sel.className = "selection";
    sel.setAttribute("data-row-key", rowKey);
    
    // СОЗДАЕМ СЛОЙ ДЛЯ СТАТУСОВ
    var statusLayer = document.createElement("div");
    statusLayer.className = "statusLayer";
    statusLayer.style.position = "absolute";
    statusLayer.style.width = "100%";
    statusLayer.style.height = "100%";
    statusLayer.style.pointerEvents = "none";
    
    // СОЗДАЕМ СЛОЙ ДЛЯ БРОНИРОВАНИЙ
    var bookingsLayer = document.createElement("div");
    bookingsLayer.className = "bookingsLayer";
    bookingsLayer.style.position = "absolute";
    bookingsLayer.style.width = "100%";
    bookingsLayer.style.height = "100%";
    bookingsLayer.style.pointerEvents = "none";

    // Добавляем все элементы в правильном порядке
    row.appendChild(cellsContainer);
    row.appendChild(sel);
    row.appendChild(statusLayer);
    row.appendChild(bookingsLayer);

    return row;
}

function findRowByKey(rowKey) {
	var rows = el.rowsContent.children;
	for (var i = 0; i < rows.length; i++) {
		if (rows[i].getAttribute("data-row-key") === rowKey) return rows[i];
	}
	return null;
}
//booking.js
var intersectionCache = {};

function checkIntersectionCached(start1, end1, start2, end2) {
	var key = start1.valueOf() + '|' + end1.valueOf() + '|' + start2.valueOf() + '|' + end2.valueOf();

	if (intersectionCache[key] === undefined) {
		intersectionCache[key] = end1.isAfter(start2) && start1.isBefore(end2);
	}

	return intersectionCache[key];
}

function intersectsVisibleRange(item, range) {
	var start = dayjs(item.start);
	var end = dayjs(item.end);
	return checkIntersectionCached(start, end, range.start, range.end); // ← Правильный порядок
}

function renderVisibleItems() {
    var colRange = getVisibleColumnRange();
    var rows = getVisibleRowRange();

    for (var i = rows.first; i <= rows.last; i++) {
        var ap = apartments[i];
        var row = findRowByKey(apartmentRowId(ap.id));
        if (!row) continue;

        var bookingLayer = row.querySelector(".bookingsLayer");
        var statusLayer = row.querySelector(".statusLayer");

        if (!bookingLayer || !statusLayer) continue;

        bookingLayer.innerHTML = "";
        statusLayer.innerHTML = "";

        var apBookings = bookingsByApartment[ap.id] || [];
        var apStatuses = statusesByApartment[ap.id] || [];

        // ВАЖНО: используем ту же логику фильтрации, что и в старом коде
        var visibleRange = getVisibleRange();
        
        for (var b = 0; b < apBookings.length; b++) {
            var booking = apBookings[b];
            if (!intersectsVisibleRange(booking, visibleRange)) continue;
            var elB = createBookingEl(booking);
            if (elB) bookingLayer.appendChild(elB);
        }
        
        for (var s = 0; s < apStatuses.length; s++) {
            var status = apStatuses[s];
            if (!intersectsVisibleRange(status, visibleRange)) continue;
            var elS = createApartmentStatusEl(status);
            if (elS) statusLayer.appendChild(elS);
        }
    }
}

function createBookingEl(b, forceRender = false) {
    var start = dayjs(b.start);
    var end = dayjs(b.end);
    
    // Проверяем пересечение с видимым диапазоном
    if (!forceRender) {
        var range = getVisibleRange();
        if (!intersectsVisibleRange(b, range)) {
            return null;
        }
    }
    
    // ВАЖНО: Используем правильную логику для расчета позиции
    // В ручном режиме нужно учитывать periodFrom как начало всей сетки
    var gridStart, totalGridDays;
    
    if (state.periodAuto) {
        gridStart = state.anchorDate.startOf("day");
        totalGridDays = state.visibleDays;
    } else {
        // В ручном режиме gridStart - это начало всего периода (periodFrom)
        // Используем allDaysArray для точного расчета
        gridStart = state.periodFrom ? state.periodFrom.startOf("day") : state.anchorDate.startOf("day");
        totalGridDays = allDaysArray.length;
    }
    
    var startDay = start.startOf("day");
    var endDay = end.startOf("day").add(1, "day"); // +1 день для корректного расчета
    
    // Если полностью вне всей сетки периода - не рендерим
    if (startDay.isSameOrAfter(gridStart.add(totalGridDays, "day")) || 
        endDay.isSameOrBefore(gridStart)) {
        return null;
    }
    
    // Рассчитываем позицию относительно начала ВСЕГО ПЕРИОДА (gridStart)
    var leftDays = startDay.diff(gridStart, "day");
    var rightDays = endDay.diff(gridStart, "day");
    
    // Ограничиваем в пределах всей сетки периода
    var clampedLeft = clamp(leftDays, 0, totalGridDays);
    var clampedRight = clamp(rightDays, 0, totalGridDays);
    
    // Вычисляем позицию в пикселях (относительно начала сетки)
    var leftPx = clampedLeft * state.columnWidth;
    var widthPx = Math.max(
        state.columnWidth,
        (clampedRight - clampedLeft) * state.columnWidth
    );
    
    var offset = 4;
    var halfOffset = state.columnWidth / 2;
    
    var isRealStartVisible = startDay.isSameOrAfter(gridStart);
    var isRealEndVisible = endDay.isSameOrBefore(gridStart.add(totalGridDays, "day"));
    
   // Левый край
if (!startDay.isBefore(gridStart)) {
    leftPx += halfOffset;
    widthPx -= halfOffset;
}

// Правый край
if (!endDay.isAfter(gridStart.add(totalGridDays, "day"))) {
    widthPx -= halfOffset;
}

// Дополнительные отступы для длинных бронирований (если > 1 видимого дня)
if (clampedRight - clampedLeft > 1) {
    leftPx += offset;
    widthPx -= offset * 2;
}

// Минимальная ширина — чтобы не сжималось до нуля
widthPx = Math.max(state.columnWidth / 2 + 1, widthPx);  // ← минимум чуть больше половины, чтобы было видно
    
    /* ===============================
       ВНЕШНИЙ КОНТЕЙНЕР (НЕ РЕЖЕТ)
    =============================== */
    var wrap = document.createElement("div");
    wrap.className = "booking-wrap";
    wrap.style.left = leftPx + "px";
    wrap.style.width = widthPx + "px";
    wrap.style.zIndex = "2";
    wrap.style.position = "absolute";
    wrap.setAttribute("data-booking-id", String(b.id));
    wrap.setAttribute("data-date-create", String(b.dateCreate || "0"));
    wrap.setAttribute("data-apartment-id", String(b.apartmentId));
    
    /* ===============================
       САМА ПОЛОСКА БРОНИ (РЕЖЕТ ТЕКСТ)
    =============================== */
    var div = document.createElement("div");
    div.className = "booking";
    div.id = bookingIdStr(b);
    div.setAttribute("data-booking-id", String(b.id));
    div.setAttribute("data-date-create", String(b.dateCreate || "0"));
    div.setAttribute("data-apartment-id", String(b.apartmentId));
    
    var color = statusColors[b.status] || "#D9E6FF";
    div.style.background = color;
    
    var label = b.guestName || ("Бронь #" + b.id);
    
    var textSpan = document.createElement("span");
    textSpan.className = "booking-label";
    textSpan.textContent =
        label + " · " +
        getFormattedDate(start, "DD.MM") + "–" + getFormattedDate(end, "DD.MM");
    
    div.appendChild(textSpan);
    wrap.appendChild(div);
    
    /* ===============================
       API-БЕЙДЖ
    =============================== */
    if (b.checkInAggregator === true) {
        var apiBadge = document.createElement("span");
        apiBadge.className = "api-badge";
        apiBadge.textContent = "api";
        wrap.appendChild(apiBadge);
        div.setAttribute('data-locked', 'true');
    }
    
    /* ===============================
       ОБРАБОТЧИКИ
    =============================== */
    wrap.onmousedown = function(ev) {
        onBookingMouseDown(ev, b);
    };
    
    wrap.onmousemove = function(ev) {
        if (fixedPopover.isFixed) return;
        if (!selectedItem.element || selectedItem.id !== b.id) {
            showBookingPopover(ev, b, false);
        }
    };
    
    wrap.onmouseleave = hidePopover;
    
    wrap.oncontextmenu = function(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        selectItem("booking", b.id, wrap, ev);
    };
    
    wrap.ondblclick = function() {
        dispatch("openDocument", b);
    };
    
    wrap.onclick = function(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        ev.stopImmediatePropagation();
        selectItem("booking", b.id, wrap, ev);
    };
    
    wrap.addEventListener('click', function(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        ev.stopImmediatePropagation();
        selectItem("booking", b.id, wrap, ev);
    });
    
    div.onclick = function(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        ev.stopImmediatePropagation();
        selectItem("booking", b.id, wrap, ev);
    };
    
    return wrap;
}


function createApartmentStatusEl(status, forceRender = false) {
    var start = dayjs(status.start);
    var end = dayjs(status.end);
    
    // Проверяем пересечение с видимым диапазоном
    if (!forceRender) {
        var range = getVisibleRange();
        if (!intersectsVisibleRange(status, range)) {
            return null;
        }
    }
    
    // ВАЖНО: Используем правильную логику для расчета позиции
    // В ручном режиме нужно учитывать periodFrom как начало всей сетки
    var gridStart, totalGridDays;
    
    if (state.periodAuto) {
        gridStart = state.anchorDate.startOf("day");
        totalGridDays = state.visibleDays;
    } else {
        // В ручном режиме gridStart - это начало всего периода (periodFrom)
        // Используем allDaysArray для точного расчета
        gridStart = state.periodFrom ? state.periodFrom.startOf("day") : state.anchorDate.startOf("day");
        totalGridDays = allDaysArray.length;
    }
    
    var startDay = start.startOf("day");
    var endDay = end.startOf("day").add(1, "day");
    
    if (startDay.isSameOrAfter(gridStart.add(totalGridDays, "day")) || 
        endDay.isSameOrBefore(gridStart)) {
        return null;
    }
    
    var leftDays = startDay.diff(gridStart, "day");
    var rightDays = endDay.diff(gridStart, "day");
    var clampedLeft = clamp(leftDays, 0, totalGridDays);
    var clampedRight = clamp(rightDays, 0, totalGridDays);
    
    var leftPx = clampedLeft * state.columnWidth;
    var widthPx = Math.max(state.columnWidth, (clampedRight - clampedLeft) * state.columnWidth);
    
    var offset = 4;
    var halfOffset = state.columnWidth / 2;
    
    var isRealStartVisible = startDay.isSameOrAfter(gridStart);
    var isRealEndVisible = endDay.isSameOrBefore(gridStart.add(totalGridDays, "day"));
    
    /* ЛЕВЫЙ КРАЙ */
    if (isRealStartVisible && clampedLeft >= 0 && clampedLeft < totalGridDays) {
        leftPx += halfOffset;
        widthPx -= halfOffset;
    } else if (clampedLeft === 0 && startDay.isBefore(gridStart)) {
        // Оставляем полную ширину
    }
    
    /* ПРАВЫЙ КРАЙ */
    if (isRealEndVisible && clampedRight > 0 && clampedRight <= totalGridDays) {
        widthPx -= halfOffset;
    } else if (clampedRight === totalGridDays && endDay.isAfter(gridStart.add(totalGridDays, "day"))) {
        // Оставляем полную ширину
    }
    
    // Отступы для длинных документов
    if (clampedRight - clampedLeft > 1) {
        leftPx += offset;
        widthPx -= offset * 2;
    }
        
    var div = document.createElement("div");
    div.className = "apartment-status";
    div.id = apartmentStatusIdStr(status);
    div.setAttribute("data-status-id", String(status.id));
    div.setAttribute("data-date-create", String(status.dateCreate || "0"));
    div.setAttribute("data-apartment-id", String(status.apartmentId));
    div.setAttribute("data-status-type", status.statusType || "other");
    
    var color = statusColors[status.status] || "#F0F0F0";
    div.style.background = color;
    div.style.opacity = "0.6";
    div.style.left = leftPx + "px";
    div.style.width = widthPx + "px";
    div.style.zIndex = "1";
    
    var label = status.reason || status.statusType || "Статус";
    div.textContent = label + " · " + start.format("DD.MM") + "–" + end.format("DD.MM");
    
    // Обработчики событий
    div.onmousemove = function(ev) {
        if (fixedPopover.isFixed) return;
        if (!selectedItem.element || selectedItem.id !== status.id) {
            showStatusPopover(ev, status, false);
        }
    };
    
    div.onmouseleave = hidePopover;
    
    div.oncontextmenu = function(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        selectItem("status", status.id, div, ev);
    };
    
    div.ondblclick = function() {
        dispatch('openDocument', status);
    };
    
    div.onmousedown = function(ev) {
        onStatusMouseDown(ev, status);
    };
    
    div.onclick = function(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        selectItem("status", status.id, div, ev);
    };
    
    return div;
}
// drag-and-drop.js
function checkItemCollision(itemId, itemType, apartmentId, newStart, newEnd) {

	// Проверяем ВСЕ бронирования (независимо от типа)
	for (var i = 0; i < bookings.length; i++) {
		var booking = bookings[i];
		if (String(booking.id) === String(itemId) && itemType === "booking") continue;
		if (booking.apartmentId !== apartmentId) continue;

		var bookingStart = dayjs(booking.start);
		var bookingEnd = dayjs(booking.end);

		if (newStart.isBefore(bookingEnd, "day") && newEnd.isAfter(bookingStart, "day")) return true;
	}

	// Проверяем ВСЕ статусы (независимо от типа)
	for (var j = 0; j < apartmentStatuses.length; j++) {
		var status = apartmentStatuses[j];
		if (String(status.id) === String(itemId) && itemType === "status") continue;
		if (status.apartmentId !== apartmentId) continue;

		var statusStart = dayjs(status.start);
		var statusEnd = dayjs(status.end);

		if (newStart.isBefore(statusEnd, "day") && newEnd.isAfter(statusStart, "day")) return true;
	}

	return false;
}

function onBookingMouseDown(ev, booking) {
	if (ev.button !== 0) return;
	if (booking.checkInAggregator === true) {
		ev.preventDefault();
		return;
	}
	
	deselectItem();
	hidePopover();

	var bookingEl = ev.currentTarget;
	var oldStartDay = dayjs(booking.start).startOf("day");
	var oldEndDay = dayjs(booking.end).startOf("day");
	var durationDays = oldEndDay.diff(oldStartDay, "day");
	
	// Получаем bounding rect относительно окна
	var rect = bookingEl.getBoundingClientRect();
	
	// ВАЖНО: Получаем позицию элемента в контейнере rowsContent
	var rowsContentRect = el.rowsContent.getBoundingClientRect();
	var leftRelativeToRowsContent = rect.left - rowsContentRect.left;
	
	var startDayIndex = Math.floor(leftRelativeToRowsContent / state.columnWidth);
	var visibleStartDate = state.anchorDate.add(startDayIndex, "day");

	var daysHiddenLeft = 0;
	if (oldStartDay.isBefore(visibleStartDate)) {
		daysHiddenLeft = visibleStartDate.diff(oldStartDay, "day");
	}

	var clickOffsetX = ev.clientX - rect.left;
	var clickedVisibleDayOffset = Math.floor(clickOffsetX / state.columnWidth);
	var clickedDayOffset = daysHiddenLeft + clickedVisibleDayOffset;
	clickedDayOffset = clamp(clickedDayOffset, 0, durationDays - 1);

	var originalStyles = {
		left: bookingEl.style.left,
		width: bookingEl.style.width,
		opacity: bookingEl.style.opacity
	};

	dragState = {
		itemId: booking.id,
		dateCreate: booking.dateCreate,
		item: booking,
		itemEl: bookingEl,
		dragEl: null,
		itemType: "booking",
		originalStartDate: oldStartDay,
		durationDays: durationDays,
		startX: ev.clientX,
		startY: ev.clientY,
		currentApartmentId: booking.apartmentId,
		isValid: true,
		hasMoved: false,
		clickedDayOffset: clickedDayOffset,
		originalStyles: originalStyles,
		dragOffsetX: ev.clientX - (rect.left - (daysHiddenLeft * state.columnWidth)),
		rect: rect,
		originalStartTime: dayjs(booking.start).format("HH:mm:ss"),
		originalEndTime: dayjs(booking.end).format("HH:mm:ss"),
		visibleWidth: parseFloat(bookingEl.style.width) || state.columnWidth
	};

	ev.preventDefault();
}

function onStatusMouseDown(ev, statusItem) {
	if (ev.button !== 0) return;
	deselectItem(); // Снимаем выделение при начале перетаскивания
	hidePopover();

	var statusEl = ev.currentTarget;
	var oldStartDay = dayjs(statusItem.start).startOf("day");
	var oldEndDay = dayjs(statusItem.end).startOf("day");
	var durationDays = oldEndDay.diff(oldStartDay, "day");
	
	// Получаем bounding rect относительно окна
	var rect = statusEl.getBoundingClientRect();
	
	// ВАЖНО: Получаем позицию элемента в контейнере rowsContent
	var rowsContentRect = el.rowsContent.getBoundingClientRect();
	var leftRelativeToRowsContent = rect.left - rowsContentRect.left;
	
	var startDayIndex = Math.floor(leftRelativeToRowsContent / state.columnWidth);
	var visibleStartDate = state.anchorDate.add(startDayIndex, "day");

	var daysHiddenLeft = 0;
	if (oldStartDay.isBefore(visibleStartDate)) {
		daysHiddenLeft = visibleStartDate.diff(oldStartDay, "day");
	}

	var clickOffsetX = ev.clientX - rect.left;
	var clickedVisibleDayOffset = Math.floor(clickOffsetX / state.columnWidth);
	var clickedDayOffset = daysHiddenLeft + clickedVisibleDayOffset;
	clickedDayOffset = clamp(clickedDayOffset, 0, durationDays - 1);

	var originalStyles = {
		left: statusEl.style.left,
		width: statusEl.style.width,
		opacity: statusEl.style.opacity
	};

	dragState = {
		itemId: statusItem.id,
		dateCreate: statusItem.dateCreate,
		item: statusItem,
		itemEl: statusEl,
		dragEl: null,
		itemType: "status",
		originalStartDate: oldStartDay,
		durationDays: durationDays,
		startX: ev.clientX,
		startY: ev.clientY,
		currentApartmentId: statusItem.apartmentId,
		isValid: true,
		hasMoved: false,
		clickedDayOffset: clickedDayOffset,
		originalStyles: originalStyles,
		dragOffsetX: ev.clientX - (rect.left - (daysHiddenLeft * state.columnWidth)),
		rect: rect,
		originalStartTime: dayjs(statusItem.start).format("HH:mm:ss"),
		originalEndTime: dayjs(statusItem.end).format("HH:mm:ss"),
		visibleWidth: parseFloat(statusEl.style.width) || state.columnWidth
	};

	ev.preventDefault();
}

function onDocumentMouseMove(ev) {
	if (!dragState) return;

	var deltaX = ev.clientX - dragState.startX;
	var deltaY = ev.clientY - dragState.startY;
	var movement = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
	if (movement > 3) {
		dragState.hasMoved = true;
	}

	if (!dragState.hasMoved) return;

	if (dragState.itemType === "booking") {
		hidePopover();
	} else {
		hidePopover();
	}

	// Если dragEl ещё не создан, создаём его
	if (!dragState.dragEl) {
		var dragEl = document.createElement("div");
		dragEl.className = "" + (dragState.itemType === "booking" ? "booking" : "apartment-status") + " dragging";
		dragEl.textContent = dragState.itemEl.textContent;
		dragEl.style.background = dragState.itemEl.style.background;
		dragEl.style.color = dragState.itemEl.style.color;
		dragEl.style.zIndex = "1000";
		dragEl.style.position = "fixed"; // Изменяем на fixed
		dragEl.style.pointerEvents = "none";

		if (dragState.itemType === "status") {
			dragEl.style.opacity = dragState.itemEl.style.opacity;
		}

		dragEl.style.width = dragState.visibleWidth + "px";
		dragEl.style.height = dragState.itemEl.offsetHeight + "px";
		dragEl.style.left = dragState.rect.left + "px";
		dragEl.style.top = dragState.rect.top + "px";

		document.body.appendChild(dragEl);
		dragState.dragEl = dragEl;

		// Полупрозрачность оригинального элемента
		dragState.itemEl.style.opacity = "0.3";
	}

	// Обновляем позицию временного элемента с шаговым перемещением по горизонтали
	var deltaX = ev.clientX - dragState.startX;
	var snappedDeltaDays = Math.round(deltaX / state.columnWidth);
	var snappedDeltaX = snappedDeltaDays * state.columnWidth;

	// Обновляем left позицию
	dragState.dragEl.style.left = (dragState.rect.left + snappedDeltaX) + "px";

	// ВАЖНО: Правильно вычисляем вертикальную позицию
	var rowsViewportRect = el.rowsViewport.getBoundingClientRect();
	
	// Получаем вертикальную позицию мыши относительно rowsViewport
	var relativeY = ev.clientY - rowsViewportRect.top + el.rowsViewport.scrollTop;
	
	// Высота строки должна быть 40px (как в CSS)
	var rowHeight = 40;
	var rowIndex = Math.floor(relativeY / rowHeight);
	var clampedRowIndex = clamp(rowIndex, 0, apartments.length - 1);
	
	// Рассчитываем новую позицию top для dragEl
	var newTop = rowsViewportRect.top + 
				 (clampedRowIndex * rowHeight) - 
				 el.rowsViewport.scrollTop;
	
	// Устанавливаем новую вертикальную позицию
	dragState.dragEl.style.top = newTop + "px";
	
	var targetApartmentId = apartments[clampedRowIndex].id;

	// Рассчитываем новую дату начала на основе смещения мыши
	var deltaDays = snappedDeltaDays;
	var newStartDay = dragState.originalStartDate.add(deltaDays, "day");
	var newStart = dayjs(newStartDay.format("YYYY-MM-DD") + "T" + dragState.originalStartTime);
	var newEndDay = newStartDay.add(dragState.durationDays, "day");
	var newEnd = dayjs(newEndDay.format("YYYY-MM-DD") + "T" + dragState.originalEndTime);

	var hasCollision = checkItemCollision(
		dragState.itemId,
		dragState.itemType,
		targetApartmentId,
		newStart,
		newEnd
	);

	dragState.currentApartmentId = targetApartmentId;
	dragState.isValid = !hasCollision;

	// Обновляем внешний вид временного элемента
	dragState.dragEl.className = dragState.dragEl.className.replace(" drag-invalid", "");
	if (hasCollision) {
		dragState.dragEl.className += " drag-invalid";
	}
}

function onDocumentMouseUp(ev) {
	if (!dragState) return;

	var ds = dragState;

	// Удаляем временный элемент
	if (ds.dragEl && ds.dragEl.parentNode) {
		ds.dragEl.parentNode.removeChild(ds.dragEl);
	}

	// Восстанавливаем оригинальный элемент
	if (ds.itemEl) {
		ds.itemEl.style.left = ds.originalStyles.left;
		ds.itemEl.style.width = ds.originalStyles.width;
		ds.itemEl.style.opacity = ds.originalStyles.opacity || "";
		ds.itemEl.className = ds.itemEl.className.replace(" dragging", "").replace(" drag-invalid", "");
	}

	if (ds.hasMoved && ds.isValid) {
		var deltaDays = Math.round((ev.clientX - ds.startX) / state.columnWidth);
		
		// Также получаем новую строку (квартиру) для перемещения
		var rowsViewportRect = el.rowsViewport.getBoundingClientRect();
		var relativeY = ev.clientY - rowsViewportRect.top + el.rowsViewport.scrollTop;
		var rowHeight = 40;
		var rowIndex = Math.floor(relativeY / rowHeight);
		var clampedRowIndex = clamp(rowIndex, 0, apartments.length - 1);
		var targetApartmentId = apartments[clampedRowIndex].id;

		var newStartDay = ds.originalStartDate.add(deltaDays, "day");
		var newEndDay = newStartDay.add(ds.durationDays, "day");

		pendingAction = {
			type: ds.itemType, // "booking" | "status"
			id: ds.itemId,
			dateCreate: ds.dateCreate,
			oldState: structuredClone(ds.item),
			newState: {
			    apartmentId: targetApartmentId,
			    start: newStartDay.format("YYYY-MM-DD") + "T" + ds.originalStartTime,
			    end: newEndDay.format("YYYY-MM-DD") + "T" + ds.originalEndTime
			}
		};

		pendingAction.oldState.itemEl = ds.itemEl;  // Добавляем ссылку на DOM-элемент
	    applyOptimisticUpdate(pendingAction);
	    dispatch(ds.itemType + "MoveRequest", pendingAction);
	} else {
		// Если просто кликнули (не перетащили) - выделяем элемент
		if (!ds.hasMoved && selectedItem.element !== ds.itemEl) {
			selectItem(ds.itemType, ds.itemId, ds.itemEl);
		}
	}
	dragState = null;
}

function applyOptimisticUpdate(action) {
    var itemType = action.type;
    var newState = action.newState;
    var oldState = action.oldState;
    
    // Удаляем старый DOM-элемент, если он есть
    if (oldState.itemEl) {
        oldState.itemEl.remove();
    }
    
    // Находим и обновляем элемент в данных
    var array = (itemType === "booking") ? bookings : apartmentStatuses;
    var index = array.findIndex(item => String(item.id) === String(action.id) && String(item.dateCreate) === String(action.dateCreate));
    if (index !== -1) {
        // Сохраняем старое состояние для rollback
        array[index].__oldState = structuredClone(oldState);
        // Применяем новые значения
        Object.assign(array[index], newState);
        
        // Перестраиваем индексы (bookingsByApartment, statusesByApartment)
        rebuildIndexes();
        
        // Перерисовываем видимые элементы
        renderVisibleItems();
    }
}

function rollbackOptimisticUpdate(action) {
    var itemType = action.type;
    var array = (itemType === "booking") ? bookings : apartmentStatuses;
    var index = array.findIndex(item => String(item.id) === String(action.id) && String(item.dateCreate) === String(action.dateCreate));
    if (index !== -1 && array[index].__oldState) {
        // Восстанавливаем старое состояние
        Object.assign(array[index], array[index].__oldState);
        delete array[index].__oldState;
        
        // Перестраиваем индексы
        rebuildIndexes();
        
        // Перерисовываем видимые элементы
        renderVisibleItems();
    }
}

document.addEventListener("mousemove", onDocumentMouseMove);
document.addEventListener("mouseup", onDocumentMouseUp);

// selection.js
var selectionHandlersAttached = false;

function attachSelectionHandlersOnce() {
	if (selectionHandlersAttached) return;
	selectionHandlersAttached = true;

	el.rowsContent.addEventListener("mousedown", function(ev) {
		if (ev.button !== 0) return;
		if (findParentWithClass(ev.target, "booking-wrap")) return;

		var cell = findParentWithClass(ev.target, "cell");
		if (!cell) return;

		var rowKey = cell.getAttribute("data-row-key");
		var apartmentId = Number(cell.getAttribute("data-apartment-id"));
		var startIndex = Number(cell.getAttribute("data-index"));

		state.selecting = {
			apartmentId: apartmentId,
			rowKey: rowKey,
			startIndex: startIndex,
			endIndex: startIndex
		};

		updateSelectionOverlay();
		ev.preventDefault();
	});

	window.addEventListener("mousemove", function(ev) {
		if (!state.selecting) return;
		var cell = findParentWithClass(ev.target, "cell");
		if (!cell) return;
		if (cell.getAttribute("data-row-key") !== state.selecting.rowKey) return;

		state.selecting.endIndex = Number(cell.getAttribute("data-index"));
		updateSelectionOverlay();
	});

	window.addEventListener("mouseup", function() {
		if (!state.selecting) return;
		if (pendingAction) return;

		var sel = state.selecting;
		var a = Math.min(sel.startIndex, sel.endIndex);
		var b = Math.max(sel.startIndex, sel.endIndex);

		// Проверяем, что выделено более одного дня
		var selectedDays = Math.abs(b - a) + 1;
		if (selectedDays < 2) {
			// Если выделен только один день - просто очищаем выделение
			clearSelectionOverlay();
			state.selecting = null;
			return;
		}
		var startDate = state.anchorDate.add(a, "day")
			.format("YYYY-MM-DD");
		var endDate = state.anchorDate.add(b + 1, "day")
			.format("YYYY-MM-DD");

		clearSelectionOverlay();

		pendingAction = {
			type: "selection",
			apartmentId: sel.apartmentId,
			startDate: startDate,
			endDate: endDate
		};

		dispatch("createDocumentRequest", pendingAction);
	});
}

function updateSelectionOverlay() {
	var sel = state.selecting;
	if (!sel) return;

	var row = findRowByKey(sel.rowKey);
	if (!row) return;

	var overlay = row.querySelector(".selection");

	var a = Math.min(sel.startIndex, sel.endIndex);
	var b = Math.max(sel.startIndex, sel.endIndex);

	overlay.style.display = "block";
	overlay.style.left = (a * state.columnWidth + 2) + "px";
	overlay.style.width = ((b - a + 1) * state.columnWidth - 4) + "px";
}

function clearSelectionOverlay() {
	var selections = el.rowsContent.querySelectorAll(".selection");
	for (var i = 0; i < selections.length; i++) {
		selections[i].style.display = "none";
	}
}

function finishSelection() {
	clearSelectionOverlay();
	state.selecting = null;
}
//ui_components.js
function showBookingPopover(ev, b, isFixed = false) {
	if (isFixed) {
		fixedPopover.isFixed = true;
		fixedPopover.type = "booking";
		fixedPopover.id = b.id;
	}
	var p = el.infoPopover;
	p.style.display = 'block';
	var ap = getApartmentById(b.apartmentId);
	var apartmentName = ap ? ap.name : b.apartmentId;
	var bookingHtml = '<div class="kv">' + '<div class="kv-row"><div class="kv-label">' + 'Квартира' + '</div><div class="kv-value">' + apartmentName + '</div></div>' + '<div class="kv-row"><div class="kv-label">' + 'Источник' + '</div><div class="kv-value">' + safe(b.aggregator) + '</div></div>' + '<div class="kv-row"><div class="kv-label">' + 'Гость' + '</div><div class="kv-value">' + safe(b.guestName) + '</div></div>' + '<div class="kv-row"><div class="kv-label">' + 'Даты' + '</div><div class="kv-value">' + dayjs(b.start).format('DD.MM.YYYY HH:mm') + ' → ' + dayjs(b.end).format('DD.MM.YYYY HH:mm') + '</div></div>' + '<div class="kv-row"><div class="kv-label">' + 'Статус' + '</div><div class="kv-value">' + safe(b.status) + '</div></div>' + '</div>';
	
	let headerHtml = `
        <div style="display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 8px;">
            <div class="title" style="margin: 0; flex: 1;">
                Бронирование #${b.id}
            </div>
    `;

    let eventIconsHtml = '';
    if (b.events && Array.isArray(b.events) && b.events.length > 0) {
        const sortedEvents = sortEvents(b.events);
        eventIconsHtml = '<div class="events-container" style="flex-shrink: 0;">';
        sortedEvents.forEach(event => {
            if (eventIcons[event]) {
                const title = eventTitles[event] || event;
                eventIconsHtml += `
                    <div class="event-icon" title="${title}">
                        ${eventIcons[event]}
                    </div>`;
            }
        });
        eventIconsHtml += '</div>';
    }

    headerHtml += eventIconsHtml + '</div>';
	
	p.innerHTML = headerHtml + bookingHtml;
	
	var buttonsDiv = document.createElement('div');
	buttonsDiv.className = 'popover-buttons';
	var btnOpen = document.createElement('button');
	btnOpen.className = 'btn-open';
	btnOpen.textContent = 'Открыть';
	btnOpen.addEventListener('click', function() {
		dispatch('openDocument', b);
	});
	var btnCopy = document.createElement('button');
	btnCopy.className = 'btn-copy';
	btnCopy.textContent = 'Скопировать';
	btnCopy.addEventListener('click', function() {
		dispatch('copyDocument', b);
	});
	buttonsDiv.appendChild(btnOpen);
	buttonsDiv.appendChild(btnCopy);
	p.appendChild(buttonsDiv);
	
	if (!isFixed) {
		var x = clamp(ev.clientX + 16, 8, window.innerWidth - 380);
		var y = clamp(ev.clientY + 16, 8, window.innerHeight - 220);
		p.style.left = x + 'px';
		p.style.top = y + 'px';
		fixedPopover.position = {
			x: x,
			y: y
		};
	} else {
		// Для фиксированной используем уже установленную позицию
		p.style.left = fixedPopover.position.x + 'px';
		p.style.top = fixedPopover.position.y + 'px';
	}
	p.onmousedown = function(e) {
		e.stopPropagation();
	};
}

function showStatusPopover(ev, status, isFixed = false) {
	if (isFixed) {
		fixedPopover.isFixed = true;
		fixedPopover.type = "status";
		fixedPopover.id = status.id;
	}
	var p = el.infoPopover;
	p.style.display = 'block';
	var ap = apartments.find(a => a.id === status.apartmentId);
	var apartmentName = ap ? ap.name : status.apartmentId;
	var statusHtml = '<div class="kv">' + '<div class="kv-row"><div class="kv-label">' + 'Квартира' + '</div><div class="kv-value">' + apartmentName + '</div></div>' + '<div class="kv-row"><div class="kv-label">' + 'Даты' + '</div><div class="kv-value">' + dayjs(status.start).format('DD.MM.YYYY HH:mm') + ' → ' + dayjs(status.end).format('DD.MM.YYYY HH:mm') + '</div></div>' + '<div class="kv-row"><div class="kv-label">' + 'Статус' + '</div><div class="kv-value">' + safe(status.statusType) + '</div></div>' + '<div class="kv-row"><div class="kv-label">' + 'Причина' + '</div><div class="kv-value">' + safe(status.reason) + '</div></div>' + '</div>';
	p.innerHTML = '<div class="title">Установка статуса квартиры #' + status.id + '</div>' + statusHtml;
	var buttonsDiv = document.createElement('div');
	buttonsDiv.className = 'popover-buttons';
	var btnOpen = document.createElement('button');
	btnOpen.className = 'btn-open';
	btnOpen.textContent = 'Открыть';
	btnOpen.addEventListener('click', function() {
		dispatch('openDocument', status);
	});
	var btnCopy = document.createElement('button');
	btnCopy.className = 'btn-copy';
	btnCopy.textContent = 'Скопировать';
	btnCopy.addEventListener('click', function() {
		dispatch('copyDocument', status);
	});
	buttonsDiv.appendChild(btnOpen);
	buttonsDiv.appendChild(btnCopy);
	p.appendChild(buttonsDiv);
	if (!isFixed) {
		var x = clamp(ev.clientX + 16, 8, window.innerWidth - 380);
		var y = clamp(ev.clientY + 16, 8, window.innerHeight - 220);
		p.style.left = x + 'px';
		p.style.top = y + 'px';
		fixedPopover.position = {
			x: x,
			y: y
		};
	} else {
		// Для фиксированной используем уже установленную позицию
		p.style.left = fixedPopover.position.x + 'px';
		p.style.top = fixedPopover.position.y + 'px';
	}
	p.onmousedown = function(e) {
		e.stopPropagation();
	};
}

function hidePopover() {
	// Не скрываем подсказку, если она зафиксирована
	if (!fixedPopover.isFixed) {
		el.infoPopover.style.display = 'none';
	}
}

// Функции для работы с событиями бронирований
const eventIcons = {
    email_sent: '<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" version="1.1" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"/><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"/><g id="SVGRepo_iconCarrier"> <g style="stroke:#333333;stroke-width:2"> <path style="fill:#cccccc" d="m 3,16 94,0 0,68 -94,0 z"/> <path style="fill:#e6e6e6" d="m 4,16 34,33 c 7,7 15,7 23,0 L 96,16 z"/> <path style="fill:none" d="M 96,84 59,51 M 4,84 40,51"/> </g> <path style="fill:#4CBB4F;stroke:#004100;stroke-width:3;stroke-opacity:0.6;fill-opacity:0.7" d="M 27,73 C 20,58 23,37 35,27 45,19 60,16 72,18 L 72,5 97,28 72,54 72,41 C 72,41 51,35 40,46 29,57 27,73 27,73 z"/> <path style="fill:#35ff35;fill-opacity:0.85;stroke:#007300;stroke-width:2;" d="M 4,36 C 8,42 26,73 31,93 38,82 44,63 98,12 78,22 51,44 33,60 26,55 18,44 4,36"/></g></svg>',
    email_notSent: '<svg width="256px" height="256px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" version="1.1" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"/><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"/><g id="SVGRepo_iconCarrier"> <g style="stroke:#333333;stroke-width:2"> <path style="fill:#c7c7c7" d="m 3,16 94,0 0,68 -94,0 z"/> <path style="fill:#e3e3e3" d="m 4,16 34,33 c 7,7 15,7 23,0 L 96,16 z"/> <path style="fill:none" d="M 96,84 59,51 M 4,84 40,51"/> </g> <defs> <mask id="mask_circle"> <circle cx="50" cy="50" r="50" fill="white"/> <circle cx="50" cy="50" r="12" fill="#000000"/> </mask> <linearGradient x1="20" y1="60" x2="60" y2="40" id="Gradient" gradientUnits="userSpaceOnUse"> <stop style="stop-color:#c20000;stop-opacity:1" offset="0"/> <stop style="stop-color:#ff5c5c;stop-opacity:1" offset="1"/> </linearGradient> </defs> <g transform="scale(0.6), translate(56,56)"> <path style="fill:none;stroke:#dd1d1d;stroke-width:3;" d="M 96,81 61,12 C 57,2.7 43,2.7 39,12 39,12 5.4,78 3.4,83 c -2,5 0,12 8.6,12 l 71,0 c 12,0 17,-5 13,-14 z"/> <path style="fill:url(#Gradient);stroke:#444444;stroke-width:7" d="M 91,80 58,16 C 54,7.1 46,7.1 42,16 42,16 11,77 9,81 6.2,86 5.8,91 14,91 l 67,0 c 12,0 14,-3 10,-11 z"/> <path style="fill:#333333;" d="M 46,63 43,35 57,35 54,63 z"/> <circle cx="50" cy="73" r="7" style="fill:#333333"/> </g> </g></svg>'
};

const eventTitles = {
    email_sent: 'Приветственное письмо отправлено',
    email_notSent: 'Приветственное письмо не отправлено',
    payment_received: 'Оплата получена',
    cleaning_scheduled: 'Уборка запланирована',
    key_delivered: 'Ключ передан',
    document_signed: 'Документ подписан',
    review_requested: 'Отзыв запрошен',
    maintenance_completed: 'Обслуживание завершено'
};

// Порядок отображения событий (первое - самое важное/последнее)
const eventOrder = [
    'checkin_code',
    'payment_received',
    'document_signed',
    'key_delivered',
    'email_sent',
    'cleaning_scheduled',
    'review_requested',
    'maintenance_completed'
];

function sortEvents(events) {
    if (!events || !Array.isArray(events)) return [];
    
    return events.sort((a, b) => {
        const indexA = eventOrder.indexOf(a);
        const indexB = eventOrder.indexOf(b);
        if (indexA === -1) return 1;
        if (indexB === -1) return -1;
        return indexA - indexB;
    });
}

function renderEventIcons(events) {
    if (!events || events.length === 0) return '';
    
    const sortedEvents = sortEvents(events);
    let iconsHtml = '<div class="events-container">'; // ← использовать div вместо span
    
    sortedEvents.forEach(event => {
        if (eventIcons[event]) {
            const title = eventTitles[event] || event;
            iconsHtml += `<div class="event-icon" title="${title}">${eventIcons[event]}</div>`;
        }
    });
    
    iconsHtml += '</div>';
    return iconsHtml;
}
// timeline.js
function renderNowLine() {
	var now = dayjs();
	var start = state.anchorDate.startOf("day");
	var idx = now.startOf("day").diff(start, "day");

	if (idx < 0 || idx >= state.visibleDays) {
		el.nowLine.style.display = "none";
		return;
	}

	var minutes = now.diff(now.startOf("day"), "minute");
	var offset = minutes / (24 * 60);
	var left = idx * state.columnWidth + offset * state.columnWidth;

	el.nowLine.style.display = "block";
	el.nowLine.style.left = (left - el.rowsViewport.scrollLeft) + "px";
}

setInterval(renderNowLine, 600000); // каждые 10 минут

function syncHeaderScroll() {
	// Синхронизируем скролл только если оба контейнера доступны
	if (el.daysViewport && el.rowsViewport) {
		el.daysViewport.scrollLeft = el.rowsViewport.scrollLeft;
	}
	renderNowLine();
}
// 1c-api.js
window.GoToDate = function(dateStr) {
	state.anchorDate = dayjs(dateStr).startOf("day");
	renderAll();
	return {
		success: true
	};
};

window.PrevDay = function() {
	state.anchorDate = state.anchorDate.add(-1, "day");
	renderAll();
	return {
		success: true
	};
};

window.NextDay = function() {
	state.anchorDate = state.anchorDate.add(1, "day");
	renderAll();
	return {
		success: true
	};
};

window.PrevWeek = function() {
	state.anchorDate = state.anchorDate.add(-7, "day");
	renderAll();
	return {
		success: true
	};
};

window.NextWeek = function() {
	state.anchorDate = state.anchorDate.add(7, "day");
	renderAll();
	return {
		success: true
	};
};

window.GoToToday = function() {
	state.anchorDate = dayjs().startOf("day");
	renderAll();
	return {
		success: true
	};
};

window.SetScale = function(width) {
	if (typeof width !== "number" || width < 72 || width > 140) {
		return {
			success: false,
			error: "Ширина столбца должна быть от 72 до 140"
		};
	}
	state.columnWidth = width;
	renderAll();
	return {
		success: true
	};
};

window.SetPeriodAuto = function(isAuto) {
	state.periodAuto = !!isAuto;
	clearAllCaches(); // Очистка при смене режима
	
	// Если переключаемся в ручной режим, сбрасываем скролл и устанавливаем anchorDate на начало периода
	if (!state.periodAuto) {
		// Сбрасываем скролл к началу периода
		el.rowsViewport.scrollLeft = 0;
		el.daysViewport.scrollLeft = 0;
		
		// ВАЖНО: Устанавливаем anchorDate на начало периода для согласованности
		if (state.periodFrom) {
			state.anchorDate = state.periodFrom.clone();
		}
	}
	
	onPeriodChanged();
	applyScrollMode();
	renderAll();
	return {
		success: true
	};
};

window.SetPeriod = function(fromStr, toStr) {
    var from = dayjs(fromStr);
    var to = dayjs(toStr);
    if (!from.isValid() || !to.isValid()) {
        return {
            success: false,
            error: "Ожидается формат YYYY-MM-DD"
        };
    }
    state.periodAuto = false;
    state.periodFrom = from.startOf("day");
    state.periodTo = to.startOf("day");
    
    // ВАЖНО: Обновляем anchorDate на начало периода
    state.anchorDate = state.periodFrom.clone();
    
    // Заполняем allDaysArray dayjs объектами
    allDaysArray = [];
    totalDaysCount = 0;
    var current = state.periodFrom.clone();
    var end = state.periodTo;
    
    while (current.isSameOrBefore(end)) {
        allDaysArray.push(current.clone());
        current = current.add(1, 'day');
    }
    
    totalDaysCount = allDaysArray.length;
    // ВАЖНО: visibleDays должно быть равно количеству видимых дней, а не всего периода!
    state.visibleDays = calcAutoVisibleDays();
    
    clearAllCaches();
    onPeriodChanged();
    renderAll();
    return {
        success: true
    };
};

window.SetTariffMode = function(enabled) {
	state.tariffMode = !!enabled;
	renderAll();
	return {
		success: true
	};
};

// Методы для работы с данными
window.updateApartments = function(jsonString) {
	try {
		apartments = JSON.parse(jsonString);
		apartmentCache = {};
		rebuildIndexes();
		renderAll();
		
		checkAndRequestData(true);
		
		return {
			success: true,
			count: apartments.length
		};
	} catch (e) {
		console.error("Ошибка парсинга JSON квартир:", e);
		return {
			success: false,
			error: e.message
		};
	}
};

window.updateApartmentStatuses = function(jsonString) {
	try {
		apartmentStatuses = JSON.parse(jsonString);
		rebuildIndexes();
		renderVisibleItems();

		return {
			success: true,
			count: apartmentStatuses.length
		};
	} catch (e) {
		console.error("Ошибка парсинга JSON статусов:", e);
		return {
			success: false,
			error: e.message
		};
	}
};
window.updateBookings = function(jsonString) {
	try {
		bookings = JSON.parse(jsonString);
		rebuildIndexes();
		renderVisibleItems();


		return {
			success: true,
			count: bookings.length
		};
	} catch (e) {
		console.error("Ошибка парсинга JSON бронирований:", e);
		return {
			success: false,
			error: e.message
		};
	}
};

window.setStatusColors = function(jsonString) {
	if (typeof jsonString !== 'string' || !jsonString.trim()) {
		return {
			success: false,
			error: 'Ожидается непустая JSON-строка'
		};
	}

	try {
		const colors = JSON.parse(jsonString);

		if (typeof colors !== 'object' || colors === null) {
			return {
				success: false,
				error: 'JSON должен быть объектом'
			};
		}

		statusColors = {};

		for (const status in colors) {
			if (colors.hasOwnProperty(status)) {
				const color = colors[status];
				if (typeof color === 'string' && /^#[0-9A-Fa-f]{6}$/i.test(color)) {
					statusColors[status] = color;
				} else {
					console.warn(`Пропущен некорректный цвет для "${status}": ${color}`);
				}
			}
		}

		renderVisibleItems();

		return {
			success: true,
			count: Object.keys(statusColors).length
		};
	} catch (e) {
		console.error('Ошибка парсинга JSON цветов статусов:', e);
		return {
			success: false,
			error: 'Невалидный JSON: ' + e.message
		};
	}
};
window.confirmPendingAction = function() {
    if (!pendingAction) return { success: false };
    if (pendingAction.type === "selection") {
        finishSelection(false);
    } else {
        // Удаляем временное поле __oldState при успехе
        var itemType = pendingAction.type;
        var array = (itemType === "booking") ? bookings : apartmentStatuses;
        var index = array.findIndex(item => String(item.id) === String(pendingAction.id) && String(item.dateCreate) === String(pendingAction.dateCreate));
        if (index !== -1) {
            delete array[index].__oldState;
        }
    }
    pendingAction = null;
    renderVisibleItems();
    return { success: true };
};

window.cancelPendingAction = function() {
    if (!pendingAction) return { success: false };
    if (pendingAction.type === "selection") {
        finishSelection(true);
    } else {
        rollbackOptimisticUpdate(pendingAction);
    }
    pendingAction = null;
    renderVisibleItems();
    return { success: true };
};

window.renderNowLinefrom1C = function() {
	renderNowLine()
};

function rebuildIndexes() {
	bookingsByApartment = {};
	statusesByApartment = {};

	for (var i = 0; i < bookings.length; i++) {
		var b = bookings[i];
		if (!bookingsByApartment[b.apartmentId]) bookingsByApartment[b.apartmentId] = [];
		bookingsByApartment[b.apartmentId].push(b);
	}

	for (var j = 0; j < apartmentStatuses.length; j++) {
		var s = apartmentStatuses[j];
		if (!statusesByApartment[s.apartmentId]) statusesByApartment[s.apartmentId] = [];
		statusesByApartment[s.apartmentId].push(s);
	}

}

window.requestDocumentsForRange = function(startDate, endDate, apartmentIds) {
	dispatch("loadDataRequest", {
		startDate,
		endDate,
		apartmentIds
	});



};


window.onDocumentsLoaded = function() {
	renderVisibleItems();

	return {
		success: true
	};
};
// init.js

(function init() {

	// Инициализация кэшей
	window.dateFormatCache = {};
	window.intersectionCache = {};
	window.apartmentCache = {};
	window.cachedDates = [];

	// Функция очистки всех кэшей при изменении периода
	window.clearAllCaches = function() {
		dateFormatCache = {};
		intersectionCache = {};
		apartmentCache = {};
		cachedDates = [];
	};

	// Подписываемся на изменение периода
	var originalSetPeriod = window.SetPeriod;
	window.SetPeriod = function(fromStr, toStr) {
		clearAllCaches(); // Очищаем кэши
		return originalSetPeriod(fromStr, toStr);
	};
	
	// 1. Первый рендер
	renderAll();

	let scrollCounter = 0;
	let isTicking = false;
	
	setInterval(() => {
	  if (scrollCounter > 0) {
	    console.log("scroll events / sec =", scrollCounter);
	    scrollCounter = 0;
	  }
	}, 1000);
	
	el.rowsViewport.addEventListener("scroll", () => {
    scrollCounter++;
    
    // ВАЖНО: Обновляем anchorDate при скролле в ручном режиме
    /*if (!state.periodAuto && state.periodFrom) {
        var scrollLeft = el.rowsViewport.scrollLeft;
        var scrollDays = Math.floor(scrollLeft / state.columnWidth);
        state.anchorDate = state.periodFrom.add(scrollDays, 'day');
    }*/
    
    // Если кадр еще не отрисован, выходим и ждем
    if (!isTicking) {
        window.requestAnimationFrame(() => {
            // Выполняем синхронизацию и рендер только в свободный кадр (60 FPS)
            syncHeaderScroll();
            //renderHeaderDays(); // ДОБАВЬТЕ ЭТО - обновлять заголовок при скролле!
            renderVisibleRows(); 
            renderVisibleItems();
            
            isTicking = false; // Разрешаем следующий вызов
        });
        isTicking = true; // Блокируем новые вызовы до завершения анимации
    }
});

	// 3. Клик вне элементов — снятие выделения
	document.addEventListener('click', function(ev) {
		// ВСЕГДА сначала проверяем элементы
		var target = ev.target;

		// 1. Проверяем бронирования
		var bookingWrap = findParentWithClass(target, 'booking-wrap');
		if (bookingWrap) {
			// Не снимаем выделение при клике на бронирование
			return;
		}

		// 2. Проверяем статусы
		var statusEl = findParentWithClass(target, 'apartment-status');
		if (statusEl) {
			// Не снимаем выделение при клике на статус
			return;
		}

		// 3. Проверяем popover
		var clickedInsidePopover = !!findParentWithClass(target, 'info-popover');

		// 4. Только если клик НЕ по этим элементам - снимаем выделение
		if (!clickedInsidePopover) {
			fixedPopover.isFixed = false;
			hidePopover();
			deselectItem();
		}
	});

	// 4. Предотвращаем выделение текста (mousedown)
	document.addEventListener('mousedown', function(ev) {

		if (findParentWithClass(ev.target, 'info-popover')) return;

		const tags = ['INPUT', 'TEXTAREA', 'SELECT'];
		if (tags.includes(ev.target.tagName)) return;

	});

	// 5. selectstart — ТОЛЬКО предотвращение выделения, НИЧЕГО БОЛЬШЕ
	document.addEventListener('selectstart', function(ev) {

		if (findParentWithClass(ev.target, 'info-popover')) return;

		const tags = ['INPUT', 'TEXTAREA', 'SELECT'];
		if (tags.includes(ev.target.tagName)) return;

		if (isInsideApp(ev.target)) {
			ev.preventDefault();
		}

	});
	attachSelectionHandlersOnce();
	
	// Проверяем, есть ли ResizeObserver (встроенный или из polyfill)
	if (typeof ResizeObserver !== 'undefined') {
		const resizeObserver = new ResizeObserver(() => {
			const days = calcAutoVisibleDays();
			if (days !== state.visibleDays) {
				state.visibleDays = days;
				renderAll();
			}
		});
		resizeObserver.observe(el.rowsViewport);
	} else {
		console.warn('ResizeObserver не поддерживается в этом браузере. Автоматическая коррекция ширины отключена.');
		// Здесь можно добавить fallback, но для простоты просто пропустим
	}
	
	
})();
		</script>
	</body>
</html>
